<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="../css/style.css">
</head>
<body>
    <nav class="header-container">
        <ul>
            <li><a href="../index.html">Home</a></li>
           <li id="fundamentos"><a href="#">Fundamentos de OpenGL</a>
            <ul id="Fundamentos-list">
                <li><a href="Criando Janela.html">Criando uma aplicação</a></li>
                <li><a href="Renderizando um triangulo.html">Renderizando uma triangulo</a></li>
                <li><a href="Iniciando um shader.html">Iniciando shader</a></li>
                <li><a href="Adicionando Movimento.html">Adicionando movimento</a></li>
            </ul>
           </li>
        </ul>
    </nav>
    <nav class="header-container__mobile">
        <ul>
            <li><a href="index.html">Home</a></li>
           <li id="fundamentos1"><a href="#">Fundamentos de OpenGL</a>
            <ul id="Fundamentos-list1">
                <li><a href="Criando Janela.html">Criando uma aplicação</a></li>
                <li><a href="Renderizando uma triangulo.html">Renderizando uma triangulo</a></li>
                <li><a href="Iniciando um shader.html">Iniciando shader</a></li>
                <li><a href="Adicionando Movimento.html">Adicionando movimento</a></li>
                <li><a href="Renderizando uma janela.html">Renderizando uma janela</a></li>
                <li><a href="Renderizando uma janela.html">Renderizando uma janela</a></li>
                <li><a href="Renderizando uma janela.html">Renderizando uma janela</a></li>
                <li><a href="Renderizando uma janela.html">Renderizando uma janela</a></li>
            </ul>
           </li>
        </ul>
    </nav>
    <main>
        <h2>MVP matrix</h2>
        <p>Com os conhecimentos dos outros artigos, já é possivel renderizar um objeto na window e adicionar um shader, porém, o retangulo que 
            criamos, é estático. 

            Nesse artigo, será discutido como adicionar movimentação a esse retangulo. Para fazer isso, é utilizado o conceito de MVP matrix, que 
            consiste em uma matriz composta. essa matriz MVP é formada por três matrizes, e são elas: <br> <br>
            <b>Model: </b> responsável por definir a posição, a rotação e a escala. <br>
            <b>View: </b> define a posição da camera e sua orientação. <br>
            <b>Projection: </b> Define como a cena será projetada na tela. <br>
            A matriz final é obtida multiplicando essas três matrizes na ordem correta: MVP = P . V . M
        
            É importante dizer que o pipeline gráfico moderno não aplica automaticamente transformações aos vértices. Isso significa que precisamos passar manualmente a matriz MVP para o shader.
        </p><br>
        <span class="center">Abaixo, as alterações no shader necessárias:</span>
        <div class="main-code">
            #version 330 Core <br>
            layout(location = 0) in vec4 pos;<br>
            uniform mat4 model; <br>
            uniform mat4 view;<br>
            uniform mat4 proj;<br>
            void main()<br>
            {<br>
                gl_Position = proj * view * model * pos; <br>
            }
        </div>
        <h2>o Conceito de uniform</h2>
        <p>O código acima utiliza um uniform para definir a MVP matrix.
            Os uniforms são variáveis que permanecem constantes durante a execução de um shader program para um determinado draw call. Eles são amplamente usados para passar dados da CPU para os shaders, como matrizes de transformação, cores, posições de luzes e outras informações globais.    
            <br>
            Agora, é necessário definir os valores que serão usados no MVP matrix, para isso, se utiliza a função 
            <span class="main-code-inline">UniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)</span> <br>
     <br>
            Os parametros usados são: <br>
            <b>location</b> → O identificador do uniform no shader. Esse valor é obtido com glGetUniformLocation() <br>
            <b>count</b> → O número de matrizes 4x4 que estamos enviando. Normalmente é 1 <br>
            <b>transpose</b> → Indica se a matriz deve ser transposta antes de ser usada. <br>
            <b>value</b> → O ponteiro para os dados da matriz.
        </p>
        <h2>GLM</h2>
        <p>Para criar a MVP matrix e enviar ao shader, utilizaremos a biblioteca glm;
            
            <p>Baixe o glm, via <a target="_blank" href="https://github.com/g-truc/glm">https://github.com/g-truc/glm</a>, extraia o arquivo, depois adicione o glm-master como diretorio de inclusão adicional no seu projeto.</p>
            <p>Após isso, você já terá configurado o glm e apenas precisa adicionar agora os arquivos de inclusão.</p>
            <div class="main-code-inline">
#include                &lt;glm/glm.hpp&gt; <br>
#include                &lt;glm/gtc/matrix_transform.hpp&gt; <br>
            </div>
            <p>Agora iremos aplicar os uniforms. Para isso, inicializamos três variaveis: a matriz Model como uma matriz identidade. <br>
            a matriz View usando o glm::lookAt que posiciona e orienta a câmera a partir de três parâmetros: <br>
                glm::lookAt(<br>
                cameraPosition,  // Posição da câmera<br>
                targetPosition,  // Para onde a câmera olha<br>
                upVector         // Eixo "para cima" da câmera<br>
            );<br>
            Por ultimo, para a matriz projection, criaremos uma projeção em perspectiva, usando glm::perspective. Abaixo o código <br>
        </p>
            <div class="main-code-inline">
                glm::mat4 model = glm::mat4(1.0f); <br>
                glm::mat4 view = glm::lookAt(glm::vec3(3.0f, 3.0f, 3.0f), glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(0.0f, 1.0f, 0.0f));
                glm::mat4 projection = glm::perspective(glm::radians(45.0f), 800.0f / 800.0f, 0.1f, 100.0f);
                <span class="main-code__macro">glUniformMatrix4fv</span>(<span class="main-code__macro">glGetUniformLocation</span>(idShader,"model"), 1, GL_FALSE, &model[0][0]);
                <span class="main-code__macro"> glUniformMatrix4fv</span>(<span class="main-code__macro">glGetUniformLocation</span>(idShader, "view"), 1, GL_FALSE, &view[0][0]);
                <span class="main-code__macro">glUniformMatrix4fv</span>(<span class="main-code__macro">glGetUniformLocation</span>(idShader, "proj"), 1, GL_FALSE, &proj[0][0]);
            </div>
            <p>Como queremos implementar movimentação, não podemos usar constantes no view, para isso, criaremos 3 variáveis e são elas: camPos, camFront e camUp. O camPos, será responsavel por definir a posição da camera, já o camFront, define a posição que a camera está olhando. Com relação ao camUp, ele define o eixo "em cima" da camera.</p>
    </main>
    
    <script src="../javascript/script.js"></script>
</body>
</html>